Experiment No 1

AIM
Implementation a lexical analyzer for given language using C
ALGORITHM
1.	Start
2.	Read the input file.
3.	Check whether the  input symbol is a keyword, print it is a keyword.
4.	Check whether the current input is digit, then print it is a digit.
5.	Check whether the current input contains any special symbols, then print it is a special symbol.
6.	Check whether the current input contains any identifier, then print it is an identifier.
7.	Check whether the current input contains any operator, then print it is an operator.

Experiment No 2

AIM
     Implementation a lexical analyzer for given language using LEX tool
ALGORITHM
Token declaration Part
1.	Declare token named Head as #include”<”.*”>”
2.	Declare token named Key as  “int”|”float”|”char”|”while”|”if”|”double”|”for”|”do”|”goto”|”void”
3.	Declare token named Digit as [0-9]+
4.	Declare token named Id as [a-z][A-Z0-9a-z0-9]*|_[a-z][A-Z0-9a-z0-9]*
5.	Declare token named Op as  “+”|”-“|”*”|”/”
Translation Rule Part
1.	If input lexeme matches with token {Head} then print it is a header file.
2.	If input lexeme matches with token {Key} then print it is a keyword.
3.	If input lexeme matches with token {Digit} then print it is a Digit.
4.	If input lexeme matches with token {Id} then print it is an Identifier.
5.	If input lexeme matches with token {Op} then print it is an operator.
6.	If input lexeme matches with token “.”, then skip other patterns.
Auxiliary Procedure Part
8.	Start
9.	Read the input file.
10.	If input symbol is a keyword, print it is a keyword.
11.	Check whether the current input is #include “<”.*”>”, then print it is a header file.
12.	Check whether the current input is digit, then print it is a digit.
13.	Check whether the current input contains any identifier, then print it is an identifier.
14.	Check whether the current input contains any operator, then print it is an operator.
15.	Repeat the steps 2-8 until EOF.
16.	Stop.




Experiment No 3
AIM
     Implementation of a calculator using LEX tool 
ALGORITHM
Token declaration Part
1.	Declare token named Digit as [0-9]+|([0-9]*)”.”([0-9]+)
2.	Declare token named Add as  “+”
3.	 Declare token named Sub as “-“
4.	Declare token named Mul as “*”
5.	Declare token named Div as “/”
6.	Declare token named Pow as “ ^”
7.	Declare token named nl as “ \n”
Translation Rule Part
1.	If input lexeme matches with token {Digit} then call the function eval().
2.	If input lexeme matches with token {Add} then set op=1.
3.	If input lexeme matches with token {Sub} then set op=1.
4.	If input lexeme matches with token {Mul} then set op=1.
5.	If input lexeme matches with token {Div} then set op=1.
6.	If input lexeme matches with token {Pow} then set op=1.
7.	If input lexeme matches with token {nl} then print result as a.
Auxiliary Procedure Part
1.	Start
2.	Initialize op=0, i as integer and a and b as float.
3.	Read the input file.
4.	Check whether the current input is a digit, then call the function eval().
5.	Check whether the current input is +, the set op=1.
6.	Check whether the current input is -, the set op=2.
7.	Check whether the current input is *, the set op=3.
8.	Check whether the current input is /, the set op=4.
9.	Check whether the current input is ^, the set op=5.
10.	Repeat 5-11 lines until EOF.
11.	Stop.

Function eval()

1.	Start
2.	If op=0, then convert the ASCII value into float value and store in a.
3.	Else begin
3.1.	Convert the ASCII value into float value and store in b.
3.2.	If op=1, then a=a+b
3.3.	If op=2, then a=a-b
3.4.	If op=3, the a=a*b
3.5.	If op=4, then a=a/b
3.6.	If op=5, then a=a^b
3.6.1.	Initialize i=a
3.6.2.	Check whether b>1 then
3.6.2.1.	a=a*i
3.6.3.	Decrement b.
3.7.	Op=0.
4.	Repeat the steps until EOF.
5.	Stop.

 

INTRODUCTION TO YACC
The yacc program creates parsers that define and enforce structure for character input to a computer program. To use this program, you must supply the following inputs:
Grammar file	A source file that contains the specifications for the language to recognize. This file also contains the main, yyerror, and yylex subroutines. You must supply these subroutines.
main	A C language subroutine that, as a minimum, contains a call to the yyparse subroutine generated by the yacc program. A limited form of this subroutine is available in the yacc library.
yyerror	A C language subroutine to handle errors that can occur during parser operation. A limited form of this subroutine is available in the yacc library.
yylex	A C language subroutine to perform lexical analysis on the input stream and pass tokens to the parser. You can generate this lexical analyzer subroutine using the lex command.
When the yacc command gets a specification, it generates a file of C language functions called y.tab.c. When compiled using the cc command, these functions form the yyparse subroutine and return an integer. When called, the yyparse subroutine calls the yylex subroutine to get input tokens. The yylex subroutine continues providing input until either the parser detects an error or the yylex subroutine returns an end-marker token to indicate the end of operation. If an error occurs and the yyparse subroutine cannot recover, it returns a value of 1 to main. If it finds the end-marker token, the yyparse subroutine returns a value of 0 to main.

Experiment No 4
AIM
     Implementation of a calculator using YACC tool 
ALGORITHM
YACC  Program
Declaration Part
1.	Declare interger variable I, j=1
2.	Declare token ID
3.	Declare operators + and – as left associative
4.	Declare operators * and / as left associative
5.	Declare operators ^ as left associative
6.	Declare operators UMINUS as right associative


Grammar Part
1.	s:e'\n'{printf("%d",$1);}
2.	e:    e '+' e      {$$=$1+$3;}
       |e '-' e      {$$=$1-$3;}
       |e '*' e      {$$=$1*$3;}
       |e '/' e       {$$=$1/$3;}
       |e '^' e      {
                             int i,j=$1;
                             for(i=1;i<$3;i++)
                              {
                                  j=j*$1;
                                 $$=j;
                               }
                         }
         |'('e')'        {$$=$2;}
         |ID            {$$=$2;}       ;

 Auxiliary Procedure Part

Display message “ Enter the Expression”
Read The input and parse the Expression

LEX Program
Token declaration Part
Declare external variable yylval 

Translation Rule Part
If lexeme matches with pattern [0-9] then return token ID
If lexeme matches with pattern [+-/*^\n] then return *yyrtext
If lexeme matches with pattern [.]then return yytext(0)









Experiment No 5
AIM
Program to find ε – closure of all states of any given NFA with ε transition

ALGORITHM
1.	Start
2.	Declare structure and various functions
3.	Declare function for find closure,insert trantbl, findalpha, print closure
4.	Declare local variables
5.	Read no of alphabets and then alphabets in automata(use e for epsilon)
6.	Read no of states
7.	Read no of transitions
8.	Read transition as matrix form 
9.	Call the function to insert transition table
10.	For each state in the automata call the function find closure and then call the function e-closure

Sample


                                    0                                           1                                        0 
                                                                  
Experiment No 6
AIM
     Program to convert  ε-NFA to NFA
ALGORITHM
A e-NFA is a nondeterministic finite automaton which has e-transitions in addition to the nondeterministic transitions it already had, which means, a transition can take place from one state to another even when there is no input symbol at all(meaning the input is a null string).
                                                                               Sample 
No Change In Initial State
No Change In The Total No. Of States                  a                               b                        c                                           
May Be Change In Final States
Let M=(Q,Σ,δ,q0,F) – ε-NFA
M1= (Q1,Σ,δ1,q01,F1) – NFA
1) Initial State
q01=q0
2) Construction Of δ11
δ11
(q,x)=ε-Closure(δ(ε-Closure(q),x)
3) Final State
Every State Who’s ε-Closure Contain Final State Of ε-NFA Is Final State In NFA
1.	Start
2.	Declare structure and various functions
3.	Declare function for find closure,insert trantbl, findalpha,union closure,find final closure and  print closure
4.	Declare local variables
5.	Read no of alphabets and then alphabets in automata(use e for epsilon)
6.	Read no of states
7.	Read no of transitions
8.	Read transition as matrix form 
9.	Call the function to insert transition table
10.	For each state in the automata call the function find closure 
11.	And then call the function unionclosure ,print e closure and  findfinalstate function

 
Experiment No 7
AIM
Write a Program to convert  NFAto DFA
ALGORITHM
1.	 Take ∈ closure for the beginning state of NFA as beginning state of DFA.
2.	 Find the states that can be traversed from the present for each input symbol
(union of transition value and their closures for each states of NFA present in current state of DFA).
3.	If any new state is found take it as current state and repeat step 2.
4.	Do repeat Step 2 and Step 3 until no new state present in DFA transition table.
5.	 Mark the states of DFA which contains final state of NFA as final states of DFA.
                                a,b                         b
                                        
                              q1                           q2                              q3
                                                                           a,b                       
                                                                                                     b
   
sample


Link  :   https://mycodetechniques.blogspot.com/search/label/Compiler 
Experiment No 8
AIM
Implementation of  Intermediate code generation for simple expressions
ALGORITHM

1.	Start 
2.	Declare the arrays for operation, arguments and result
3.	Create an input file as input.txt 
4.	Create an output file as blank for output the  ICG code
5.	Read from the input file and store the values for various operation
6.	Check  each operation and implement the operation code 
7.	Write  the corresponding code to output file
8.	Repeat the steps 6 and 7 till end of file(input.txt)
9.	Stop 















Experiment No 9
AIM
Implementation of Language Acceptance (anb)
ALGORITHM

1.	 Start 
2.	Define variables A,B & NL as tokens
3.	Define the rules for accepting and rejecting the given string
4.	Read the string entered by the user
5.	Print “String matched” if it obeys the rule otherwise print “invalid input”.
6.	Stop 


















Experiment No 10
AIM
Program to find Simulate First and Follow of any given grammar.
ALGORITHM
1.	Start 
2.	Declare the functions to find the first and follow
3.	Local variable declarations for rules count and  for string(rules)
4.	Declare  character array to store first and follow after calculation
5.	Read the rules
6.	Initialize the loop to find the first of each grammer(non terminals) and print
7.	Then initialize the loop to the followt of each grammer(non terminals) and print
8.	Stop 

















Experiment No 11

AIM
Recursive descent parsing using C for the given grammar
E -> E+T | T
T -> T*F | F
F -> (E) | id

ALGORITHM:
First we have to avoid left recursion

E -> TE'
E' -> +TE' | ε
T -> FT'
T' -> *FT' | ε
F -> (E) | id

After eliminating Left recursion, we have to simply move from one character to next by checking whether it follow the grammar. In this program, ε is indicated as $.













CODES

1. Implementation of Lexical Analyser using C
#include<stdio.h>
#include<ctype.h>
#include<stdlib.h>

main()
{
        FILE *f1;
char c,str[100];
int num=0,i=0,lineno=1;
        f1=fopen("input.c","r");
while((c=getc(f1))!=EOF)
        {
if(isdigit(c))
                {
num=c-48;
                        c=getc(f1);
while(isdigit(c))
                        {
num=num*10+(c-48);
                                c=getc(f1);
                        }
printf("%d is a number \n",num);
ungetc(c,f1);
                }
else if(isalpha(c))
                {
str[i++]=c;
                        c=getc(f1);
while(isdigit(c)||isalpha(c)||c=='_'||c=='$')
                        {
str[i++]=c;
                                c=getc(f1);
                        }
str[i++]='\0';
                        if(strcmp("for",str)==0||strcmp("while",str)==0||strcmp("do",str)==0||strcmp("int",str)==0||strcmp("float",str)==0||strcmp("char",str)==0||strcmp("double",str)==0||strcmp("static",str)==0||strcmp("switch",str)==0||strcmp("case",str)==0)
printf("%s is a keyword \n",str);
else
printf("%s is a identifier \n",str);
ungetc(c,f1);
                        i=0;
                }
else if(c==' '||c=='\t')
printf("\n");
else if(c=='\n')
lineno++;
else
printf("%c is a special symbol \n",c);
        }
printf("Total no. of lines are: %d \n",lineno);
fclose(f1);

}
Output

[cs1633@LabServer ~]$ cc lex.c
[cs1633@LabServer ~]$ ./a.out
 Enter the file name of program
lex.c
# is a special symbol
include is identifier
< is a special symbol
ctype is identifier
. is a special symbol
h is identifier
> is a special symbol
# is a special symbol
include is identifier
< is a special symbol
stdio is identifier
. is a special symbol
h is identifier
> is a special symbol
# is a special symbol
include is identifier
.
.
..
..

2.Implementation of Lexical Analyser using LEX tool

%{
#include<stdio.h>
#include<string.h>
char key[100][100],head[100][100],dig[100][100],op[100][100],id[100][100];
int i=0,j=0,k=0,l=0,a=0,b=0,c=0,d=0,m=0,n=0;
%}

KW "int"|"while"|"if"|"else"|"for"|"char"|"float"|"case"|"switch"
HF "#include<".*">"
OP "+"|"-"|"*"|"/"|"="
DIG [0-9]*|[0-9]*"."[0-9]+
ID [a-zA-Z][a-zA-Z0-9]*

%%
{KW} {strcpy(key[i],yytext);i++;}
{HF} {strcpy(head[j],yytext);j++;}
{DIG} {strcpy(dig[k],yytext);k++;}
{OP} {strcpy(op[m],yytext);m++;}
{ID} {strcpy(id[n],yytext);n++;}
. {}
%%

main()
{
	yyin=fopen("input.c","r+");
	yylex();
	printf("\nThe keywords are");
	for(a=0;a<i;a++)
	{
		printf("\n%s",key[a]);
	}
	printf("\nThe headerfiles are ");
	for (b=0;b<j;b++)
	{
		printf("\n%s",head[b]);
	}

	printf("\nThe digits are");
	for(c=0;c<k;c++)
	{
		printf("\n%s",dig[c]);
	}
	printf("\noperators ...");
	for (d=0;d<m;d++)
	{
		printf("\n%s",op[d]);
	}
	printf("\nidentifiers....");
	for(d=0;d<n;d++)
	{
		printf("\n%s",id[d]);
	}
}

int yywrap()
{
	printf("Errors..\n");
	return 1;
}

Output
[cs1636@LabServer s7comp]$ lex lex.l
[cs1636@LabServer s7comp]$ cc lex.yy.c
[cs1636@LabServer s7comp]$ ./a.out

The keywords are
int
float
The headerfiles are
#include<stdio.h>
The digits are
0
0.00
operators...

=
=
identifiers...

void
void
void
void
void
void
void[cs1636@LabServer s7comp]$

3. Implementation of Calculator using LEX

%{
	#include<stdio.h>
	#include<stdlib.h>
	int op=0;
	float a,b,n,i;
	void digit();

%}
digit [0-9]+|[0-9]*"."[0-9]+
add "+"
sub "-"
mul "*"
div "/"
pow "^"
end "\n"
%%

{digit} {digit();}
{add} {op=1;}
{sub} {op=2;}
{mul} {op=3;}
{div} {op=4;}
{pow} {op=5;}
{end} {printf("Result is %f",a);printf("\nEnter new equation\n");}
. {exit(0);}
%%

int main()
{
	printf("Enter the equation\n");
	yylex();
}
int vywrap()
{
	return(1);
}
void digit()
{
	if(op==0)
	{
		a=atof(yytext);
	}
	else
	{
		b=atof(yytext);
		switch(op)
{
		case 1:
			a=a+b;
			break;
		case 2:
			a=a-b;
			break;
		case 3 :
			a=a*b;
			break;
		case 4:
			a=a/b;
			break;
		case 5:
			i=1;
			n=a;
			while(i<b)
			{
				a=a*n;
				i++;
			}
			break;
		default:
			printf("invalid operation\n");
	}
	op=0;
}
}


Output

[cs1633@LabServer s7comp]$ lex cal.l
[cs1633@LabServer s7comp]$ cc lex.yy.c
[cs1633@LabServer s7comp]$ ./a.out
Enter the equation
4+7
Result is 11.000000


4. Implementation of Desktop calculator using YACC

LEX file

%{
#include "y.tab.h"
extern int yylval;
%}
DIGIT [0-9]+
OP [+|-|*|/]
%%
{DIGIT} {yylval=atoi(yytext); return NUM;}
{OP} {return *yytext;}
[\n] {return NL;}
%%

int yywrap()
{
return 1;
}

YACC file

%{
#include<stdio.h>
#include<stdlib.h>
int yylval;
%}
%token NUM NL
%left '+' '-'
%left '/''*'
%right UMINUS
%%
S:E NL{printf("result is %d",$$);}
E:E'+'E{$$=$1+$3;}
|E'-'E{$$=$1-$3;}
|'-'E %prec UMINUS{$$=-$2;}
|NUM {$$=$1;}
%%
void main()
{
yyparse();
}
int yyerror()
{
printf("input error");
}

Output
[cs1633@LabServer s7comp]$ lex calyac.l
[cs1633@LabServer s7comp]$ yacc -d calyac.y
[cs1633@LabServer s7comp]$ cc lex.yy.c y.tab.c -ll
[cs1633@LabServer s7comp]$ ./a.out
6+6
result is 12


5. C Program to findε Closure of all states of NFA

#include<stdio.h>
#include<stdlib.h>
struct node
{
	int st; 
	struct node *link;
};

void findclosure(int,int);
void insert_trantbl(int,char,int);
int findalpha(char);
void print_e_closure(int);

static int set[20],nostate,noalpha,s,notransition,c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node *transition[20][20]={NULL};

void main()
{
	int i,j,k,m,t,n;
	struct node *temp;
	printf("Enter the number of alphabets?\n");
	scanf("%d",&noalpha);
	getchar();
	printf("NOTE:-[ use leter e as epsilon]\n");
	printf("NOTE:- [e must be last character,if it is present]\n");
	printf("\nEnter alphabets?\n");
	for(i=0;i<noalpha;i++)
	{
		alphabet[i]=getchar();
		getchar();
	}
	printf("\nEnter the number of states?\n");
	scanf("%d",&nostate);
	printf("\nEnter no of transition?\n");
	scanf("%d",&notransition);
	printf("NOTE:- [Transition is in the form--> qno albhabet qno]\n",notransition);
	printf("NOTE:- [States number must be greater than zero]\n");
	printf("\nEnter transition?\n");
	for(i=0;i<notransition;i++)
	{
		scanf("%d %c%d",&r,&c,&s);
		insert_trantbl(r,c,s);
	}
	printf("\n");
	printf("e-closure of states...........\n");
	printf("------------\n");
	for(i=1;i<=nostate;i++)
	{
		c=0;
		for(j=0;j<20;j++)
		{
			buffer[j]=0;
			e_closure[i][j]=0;
		}
		findclosure(i,i);
		printf("\ne-closure(q%d): ",i);
		print_e_closure(i);
	}
}

void findclosure(int x,int sta)
{
	struct node *temp;
	int i;
	if (buffer[x])
		return;

	e_closure[sta][c++]=x;
	buffer[x]=1;
	if (alphabet[noalpha-1]=='e' && transition[x][noalpha-1]!=NULL)
	{
	temp=transition[x][noalpha-1];
	while(temp!=NULL)
	{
		findclosure(temp->st,sta);
		temp=temp->link;
	}
}}
void insert_trantbl(int r,char c,int s)
{
	int j;
	struct node *temp;
	j=findalpha(c);
if(j==999)
	{
		printf("error\n");
		exit(0);
	}
	temp=(struct node *)malloc(sizeof(struct node));
	temp->st=s;
	temp->link=transition[r][j];
	transition[r][j]=temp;
	
}
int findalpha(char c)
{
	int i;
	for(i=0;i<noalpha;i++)
	if (alphabet[i]==c)
		return i;
	return(999);
}
void print_e_closure(int i)
{
	int j;
	printf("{");
	for (j=0;e_closure[i][j]!=0;j++)
	printf("q%d,",e_closure[i][j]);
	printf("}");
}

Output
[cs1636@LabServer s7comp]$ cc eclosure.c
 [cs1636@LabServer s7comp]$ ./a.out
Enter the number of alphabets?
3
NOTE:- [ use letter e as epsilon] 
NOTE:- [e must be last character ,if it is present]

Enter alphabets?
0
1
e

Enter the number of states?
3

Enter no of transition?
5
NOTE:- [Transition is in the form–> qno alphabet qno]
NOTE:- [States number must be greater than zero]

Enter transition?
1 0 1
1 e 2
2 1 2
2 e 3
3 0 3

e-closure of states……
—————————–

e-closure(q1): {q1,q2,q3,}
e-closure(q2): {q2,q3,}
e-closure(q3): {q3,}[cs1636@LabServer s7comp]$






6. C Program for converting  ε-NFA to NFA
#include<stdio.h>
#include<stdlib.h>
struct node
{
int st; 
struct node *link;
};
void findclosure(int,int);
void insert_trantbl(int,char,int);
int findalpha(char);
void findfinalstate(void);
void unionclosure(int);
void print_e_closure(int);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node * transition[20][20]={NULL};
void main()
{
int i,j,k,m,t,n;
struct node *temp;
printf("enter the number of alphabets?\n");
scanf("%d",&noalpha);
getchar();
printf("NOTE: - [ use letter e as epsilon)\n");
printf("NOTE:- [ e must be last character ,if it is present)\n ");
printf("\nEnter alphabets?\n");
for(i=0;i<noalpha;i++)
        {
alphabet[i]= getchar();
getchar();
        }
printf("Enter the number of states ?\n");
scanf("%d" ,&nostate);
printf("Enter the start state ?\n");
scanf( "%d",&start);
printf("Enter the number of final states?\n");
scanf("%d",&nofinal);
printf("Enter the final states?\n");
for(i=0;i<nofinal;i++)
        {
scanf("%d",&finalstate[i]);
printf("Enter no of transition?\n");
scanf("%d",&notransition);
printf("NOTE:- [Transition is in the form-- > qno alphabet qno]\n" ,notransition);
printf( "NOTE:- [States number must be greater than zero]\n");
printf("\nEnter transition?\n");
for(i=0;i<notransition;i++)
                {
scanf("%d %c%d",&r,&c,&s);
                        insert_trantbl(r,c,s);
                }
printf("\n");
for(i=1;i<=nostate;i++)
                {
                        c=0;
for(j=0;j<20;j++)
                        {
buffer[j]=0;
                                e_closure[i][j]=0;
                        }
findclosure(i,i);
                }
printf("Equivalent NFA without epsilon\n");
                printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n");
printf("start state:");
                print_e_closure(start);
printf("\nAlphabets:");
for(i=0;i<noalpha;i++)
                {
printf("%c",alphabet[i]);
printf("\nStates:");
                }
for(i=1;i<=nostate;i++)
                {
                        print_e_closure(i);
                }
printf("\nTransitions are...:\n");
for(i=1;i<=nostate;i++)
                {
for(j=0;j<noalpha-1;j++)
                        {
for(m=1;m<=nostate;m++)
                                {
set[m]=0;
                                }
for(k=0;e_closure[i][k]!=0;k++)
                                {
                                        t=e_closure [i][k];
temp=transition[t][j];
while(temp!=NULL)
                                        {
unionclosure(temp->st);
temp=temp->link;
                                        }
                                }
printf("\n");
                                print_e_closure(i);
printf("%c\t",alphabet[j]);
printf("{");
for(n=1;n<=nostate;n++)
                                {
if(set[n]!=0)
                                        {
printf("q%d,",n);
                                        }
                                }
printf("}");
                        }
                }
printf("\nFinal states:");
findfinalstate();
        }
}
void findclosure(int x,int sta)
{
struct node *temp;
int i;
if(buffer[x])
return;
        e_closure[sta][c++]=x;
buffer[x]=1;
if(alphabet[noalpha-1]=='e'&&transition[x][noalpha-1]!=NULL)
        {
temp =transition[x][noalpha-1];
while(temp!=NULL)
                {
findclosure(temp->st,sta);
temp=temp->link;
    }
        }
}
void insert_trantbl(int r,char c,int s)
{
int j;
struct node *temp;
        j=findalpha(c);
if(j==999)
        {
printf("error\n");
exit(0);
        }
temp=(struct node *) malloc(sizeof(struct node));
temp->st=s;
temp-> link=transition[r][j];
transition[r][j]=temp;
}
int findalpha(char c)
{
int i;
for(i=0;i<noalpha;i++)
        {
if(alphabet[i]==c)
                {
return i;
return(999);
                }
        }
}
void unionclosure(int i)
{
int j=0,k;
while(e_closure[i][j]!=0)
        {
                k=e_closure[i][j];
set[k]=1;
j++;
        }
}
void findfinalstate()
{
int i,j,k,t;
for(i=0;i<nofinal;i++)
        {
for(j=1;j<=nostate;j++)
                {
for(k=0;e_closure[j][k]!=0;k++)
                        {
if(e_closure[j][k]==finalstate[i])
                                {
                                        print_e_closure(j);
                                }
                        }
                }
        }
}
void print_e_closure(int i)
{
int j;
printf("{");
for(j=0;e_closure[i][j]!=0;j++)
        {
printf("q%d,",e_closure[i][j]);
printf("\t");
                        }
printf("}");
                                }

Output

[cs1636@LabServer s7comp]$ ./a.out
enter the number of alphabets?
4
NOTE:- [ use letter e as epsilon] 
NOTE:- [e must be last character ,if it is present]

Enter alphabets?
a
b
c
e
Enter the number of states?
3
Enter the start state?
1
Enter the number of final states?
1
Enter the final states?
3
Enter no of transition?
5
NOTE:- [Transition is in the form--> qno   alphabet   qno]
NOTE:- [States number must be greater than zero]

Enter transition?
1 a 1
1 e 2
2 b 2
2 e 3
3 c 3

Equivalent NFA without epsilon
-----------------------------------
start state:{q1,q2,q3,}
Alphabets:a b c e
 States :{q1,q2,q3,}    {q2,q3,}        {q3,}
Tnransitions are...:

{q1,q2,q3,}     a       {q1,q2,q3,}
{q1,q2,q3,}     b       {q2,q3,}
{q1,q2,q3,}     c       {q3,}
{q2,q3,}        a       {}
{q2,q3,}        b       {q2,q3,}
{q2,q3,}        c       {q3,}
{q3,}   a       {}
{q3,}   b       {}
{q3,}   c       {q3,}
 Final states:{q1,q2,q3,}       {q2,q3,}        {q3,}   [cs1636@LabServer s7comp]$







7. NFA to DFA

#include<stdio.h>
#include<stdlib.h>
struct node
{
	int st;
	struct node *link;
};
struct node1
{

	int nst[20];
};

void insert(int ,char, int);
int findalpha(char);
void findfinalstate(void);
int insertdfastate(struct node1);
int compare(struct node1,struct node1);
void printnewstate(struct node1);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
int complete=-1;
char alphabet[20];
static int eclosure[20][20]={0};
struct node1 hash[20];
struct node * transition[20][20]={NULL};
void main()
{
	int i,j,k,m,t,n,l;
	struct node *temp;
	struct node1 newstate={0},tmpstate={0};

	printf("Enter the number of alphabets?\n");
	printf("NOTE:- [ use letter e as epsilon]\n");
	printf("NOTE:- [e must be last character ,if it is present]\n");
	scanf("%d",&noalpha);
	getchar();
	printf("\nEnter alphabets?\n");
	for(i=0;i<noalpha;i++)
	 {

		alphabet[i]=getchar();
		getchar();
	}
	printf("Enter the number of states?\n");
	scanf("%d",&nostate);
	printf("Enter the start state?\n");
	scanf("%d",&start);
	printf("Enter the number of final states?\n");
	scanf("%d",&nofinal);
	printf("Enter the final states?\n");
	for(i=0;i<nofinal;i++)
	scanf("%d",&finalstate[i]);
	printf("Enter no of transition?\n");

	scanf("%d",&notransition);
	printf("NOTE:- [Transition is in the form–> qno alphabet qno]\n",notransition);
	printf("NOTE:- [States number must be greater than zero]\n");
	printf("\nEnter transition?\n");


	for(i=0;i<notransition;i++)
	{


		scanf("%d %c%d",&r,&c,&s);
		insert(r,c,s);

	 }
	for(i=0;i<20;i++)
	{
		for(j=0;j<20;j++)
			hash[i].nst[j]=0;
	}	
	complete=-1;
	i=-1;
	printf("\nEquivalent DFA.....\n");
	printf(".......................\n");
	printf("Trnsitions of DFA\n");

	newstate.nst[start]=start;
	insertdfastate(newstate);
	while(i!=complete)
	{
		i++;
		newstate=hash[i];
		for(k=0;k<noalpha;k++)
		{
			 c=0;
			for(j=1;j<=nostate;j++)
				set[j]=0;
			for(j=1;j<=nostate;j++)
			{
				 l=newstate.nst[j];
				if(l!=0)
				{
					temp=transition[l][k];
					while(temp!=NULL)
					{
						if(set[temp->st]==0)
						{
							c++;
							set[temp->st]=temp->st;
						}
						temp=temp->link;


					     }
				}
			}
			printf("\n");
			if(c!=0)
			{
				for(m=1;m<=nostate;m++)
					tmpstate.nst[m]=set[m];

				insertdfastate(tmpstate);

				printnewstate(newstate);
				printf("%c\t",alphabet[k]);
				printnewstate(tmpstate);
					printf("\n");
			}
			else
			{
				printnewstate(newstate);
				printf("%c\t", alphabet[k]);
				printf("NULL\n");
			}

		  }
	   }
	printf("\nStates of DFA:\n");
	for(i=0;i<complete;i++)
	printnewstate(hash[i]);  
	printf("\n Alphabets:\n");	
	for(i=0;i<noalpha;i++)
	printf("%c\t",alphabet[i]);
	printf("\n Start State:\n");
	printf("q%d",start);
	printf("\nFinal states:\n");
	findfinalstate();

}

int insertdfastate(struct node1 newstate)
{
	int i;
	for(i=0;i<=complete;i++)
	{
		if(compare(hash[i],newstate))
		return 0;
	}
	complete++;
	hash[complete]=newstate;
	return 1;
}
int compare(struct node1 a,struct node1 b)
{
	int i;


	for(i=1;i<=nostate;i++)
	{
		if(a.nst[i]!=b.nst[i])
		return 0;
	}
	return 1;


}

void insert(int r,char c,int s)
{
int j;
struct node *temp;
       j=findalpha(c);
if(j==999)
       {
		printf("error\n");
		exit(0);
       }
temp=(struct node *) malloc(sizeof(struct node));
temp->st=s;
temp->link=transition[r][j];
transition[r][j]=temp;
}

int findalpha(char c)
{
int i;
for(i=0;i<noalpha;i++)
	if(alphabet[i]==c)
	return i;

return(999);


}


void findfinalstate()
{
int i,j,k,t;

for(i=0;i<=complete;i++)
  {
	for(j=1;j<=nostate;j++)
	{
		for(k=0;k<nofinal;k++)
		{
			if(hash[i].nst[j]==finalstate[k])
			{
				printnewstate(hash[i]);
				printf("\t");
				j=nostate;
				break;
			}
		}
	}
  }
}


void printnewstate(struct node1 state)
{
	int j;
	printf("{");
	for(j=1;j<=nostate;j++)
	{
		if(state.nst[j]!=0)
		printf("q%d,",state.nst[j]);
	}
	printf("}\t");

}


Output

[cs1636@LabServer s7comp]$ ./a.out
Enter the number of alphabets?
NOTE:- [ use letter e as epsilon]
NOTE:- [e must be last character ,if it is present]
2
Enter the alphabets
a
b
Enter the number of states?
4
Enter the start state?
1
Enter the number of final states?
2
Enter the final states?
3
4
Enter no of transition?
8
NOTE:- [Transition is in the form–> qno alphabet qno]
NOTE:- [States number must be greater than zero]

Enter transition?
1 a 1
1 b 1
1 a 2
2 b 2
2 a 3
3 a 4
3 b 4
4 b 3

Equivalent DFA.....
.......................
Trnsitions of DFA

{q1,}   a       {q1,q2,}

{q1,}   b       {q1,}

{q1,q2,}        a       {q1,q2,q3,}

{q1,q2,}        b       {q1,q2,}

{q1,q2,q3,}     a       {q1,q2,q3,q4,}

{q1,q2,q3,}     b       {q1,q2,q4,}

{q1,q2,q3,q4,}  a       {q1,q2,q3,q4,}

{q1,q2,q3,q4,}  b       {q1,q2,q3,q4,}

{q1,q2,q4,}     a       {q1,q2,q3,}

{q1,q2,q4,}     b       {q1,q2,q3,}

States of DFA:
{q1,}   {q1,q2,}        {q1,q2,q3,}     {q1,q2,q3,q4,}  {q1,q2,q4,}
 Alphabets:
a       b
 Start State:
q1
Final states:
{q1,q2,q3,}             {q1,q2,q3,q4,}          {q1,q2,q4,}             [cs1636@LabServer s7comp]$




8. Intermediate Code Generation

#include<ctype.h>
#include<stdio.h>
#include<string.h>
char op[2],arg1[5],arg2[5],result[5];
void main()
{
        FILE *fp1,*fp2;
        fp1=fopen("input.txt","r");
        fp2=fopen("output.txt","w");
while(!feof(fp1))
        {
fscanf(fp1,"%s%s%s%s",op,arg1,arg2,result);
if(strcmp(op,"+")==0)
                {
fprintf(fp2,"\nMOV R0,%s",arg1);
fprintf(fp2,"\nADD R0,%s",arg2);
fprintf(fp2,"\nMOV %s,R0",result);
                }
if(strcmp(op,"*")==0)
                {
fprintf(fp2,"\nMOV R0,%s",arg1);
fprintf(fp2,"\nADD R0,%s",arg2);
fprintf(fp2,"\nMOV %s,R0",result);
                }
if(strcmp(op,"-")==0)
                {
fprintf(fp2,"\nMOV R0,%s",arg1);
fprintf(fp2,"\nSUB R0,%s",arg2);
fprintf(fp2,"\nMOV %s,R0",result);
                }
if(strcmp(op,"/")==0)
                {
fprintf(fp2,"\nMOV R0,%s",arg1);
fprintf(fp2,"\nDIV R0,%s",arg2);
fprintf(fp2,"\nMOV %s,R0",result);
                }
if(strcmp(op,"=")==0)
                {
fprintf(fp2,"\nMOV R0,%s",arg1);
fprintf(fp2,"\nMOV %s,R0",result);
                }
        }
fclose(fp1);
fclose(fp2);
}

Output












9. Language Acceptance(anb)

Lex File
%{
        #include"y.tab.h"
%}

%%
"a" { return A;}
"b" { return B;}
[\n] { return NL;}
. {}
%%


Yacc File
%{
        #include<stdio.h>
int a,b;
%}
%token A B NL

%%
S: C B NL {printf("String Matched\n");};
C: A | C A;
%%

main()
{
printf("Enter String:");

yyparse();
}
void yyerror()
{
printf("Invalid input");
}

Output
 [cs15071@LabServer ~]$ lex lang.l
[cs15071@LabServer ~]$ yacc -d lang.y
[cs15071@LabServer ~]$ cc lex.yy.c y.tab.c -ll
[cs15071@LabServer ~]$ ./a.out
Enter String
aab
String Matched
[cs15071@LabServer ~]$ ./a.out
Enter a string
aba
Invalid input[cs15071@LabServer ~]$

10. First and Follow

#include<stdio.h>
#include<ctype.h>
#include<string.h>

void followfirst(char, int, int);
void follow(char c);

void findfirst(char, int, int);

int count, n = 0;

char calc_first[10][100];

char calc_follow[10][100];
int m = 0;

char production[10][10];
char f[10], first[10];
int k;
char ck;
int e;

int main(int argc, char **argv)
{
int jm = 0;
int km = 0;
int i, choice;
char c, ch;
count = 8;

strcpy(production[0], "E=TR");
strcpy(production[1], "R=+TR");
strcpy(production[2], "R=#");
strcpy(production[3], "T=FY");
strcpy(production[4], "Y=*FY");
strcpy(production[5], "Y=#");
strcpy(production[6], "F=(E)");
strcpy(production[7], "F=i");

int kay;
char done[count];
int ptr = -1;
for(k = 0; k < count; k++) {
for(kay = 0; kay < 100; kay++) {
                calc_first[k][kay] = '!';
        }
    }
int point1 = 0, point2, xxx;

for(k = 0; k < count; k++)
    {
        c = production[k][0];
        point2 = 0;
xxx = 0;

for(kay = 0; kay <= ptr; kay++)
if(c == done[kay])
xxx = 1;

if (xxx == 1)
continue;

findfirst(c, 0, 0);
ptr += 1;

done[ptr] = c;
printf("\n First(%c) = { ", c);
        calc_first[point1][point2++] = c;

for(i = 0 + jm; i < n; i++) {
int lark = 0, chk = 0;

for(lark = 0; lark < point2; lark++) {

if (first[i] == calc_first[point1][lark])
                {
chk = 1;
break;
                }
            }
if(chk == 0)
            {
printf("%c, ", first[i]);
                calc_first[point1][point2++] = first[i];
            }
        }
printf("}\n");
jm = n;
point1++;
    }
printf("\n");
printf("-----------------------------------------------\n\n");
char donee[count];
ptr = -1;

for(k = 0; k < count; k++) {
for(kay = 0; kay < 100; kay++) {
            calc_follow[k][kay] = '!';
        }
    }
    point1 = 0;
int land = 0;
for(e = 0; e < count; e++)
    {
ck = production[e][0];
        point2 = 0;
xxx = 0;

for(kay = 0; kay <= ptr; kay++)
if(ck == donee[kay])
xxx = 1;

if (xxx == 1)
continue;
land += 1;

follow(ck);
ptr += 1;

donee[ptr] = ck;
printf(" Follow(%c) = { ", ck);
        calc_follow[point1][point2++] = ck;


for(i = 0 + km; i < m; i++) {
int lark = 0, chk = 0;
for(lark = 0; lark < point2; lark++)
            {
if (f[i] == calc_follow[point1][lark])
                {
chk = 1;
break;
                }
            }
if(chk == 0)
            {
printf("%c, ", f[i]);
                calc_follow[point1][point2++] = f[i];
            }
        }
printf(" }\n\n");
km = m;
point1++;
    }
}

void follow(char c)
{
int i, j;

if(production[0][0] == c) {
f[m++] = '$';
    }
for(i = 0; i < 10; i++)
    {
for(j = 2;j < 10; j++)
        {
if(production[i][j] == c)
            {
if(production[i][j+1] != '\0')
                {

followfirst(production[i][j+1], i, (j+2));
                }

if(production[i][j+1]=='\0' && c!=production[i][0])
                {

follow(production[i][0]);
                }
            }
        }
    }
}

void findfirst(char c, int q1, int q2)
{
int j;

if(!(isupper(c))) {
first[n++] = c;
    }
for(j = 0; j < count; j++)
    {
if(production[j][0] == c)
        {
if(production[j][2] == '#')
            {
if(production[q1][q2] == '\0')
first[n++] = '#';
else if(production[q1][q2] != '\0'
&& (q1 != 0 || q2 != 0))
                {

findfirst(production[q1][q2], q1, (q2+1));
                }
else
first[n++] = '#';
            }
else if(!isupper(production[j][2]))
            {
first[n++] = production[j][2];
            }
else
            {

findfirst(production[j][2], j, 3);
            }
        }
    }
}

void followfirst(char c, int c1, int c2)
{
int k;

if(!(isupper(c)))
f[m++] = c;
else
    {
int i = 0, j = 1;
for(i = 0; i < count; i++)
        {
if(calc_first[i][0] == c)
break;
        }

while(calc_first[i][j] != '!')
        {
if(calc_first[i][j] != '#')
            {
f[m++] = calc_first[i][j];
            }
else
            {
if(production[c1][c2] == '\0')
                {

follow(production[c1][0]);
                }
else
                {

followfirst(production[c1][c2], c1, c2+1);
                }
            }
j++;
        }
    }
}

Output

[cs15071@LabServer ~]$ cc ff.c
[cs15071@LabServer ~]$ ./a.out

First(E) = { (, i, }

First(R) = { +, #, }

First(T) = { (, i, }

First(Y) = { *, #, }

First(F) = { (, i, }

-----------------------------------------------

Follow(E) = { $, ),  }

Follow(R) = { $, ),  }

Follow(T) = { +, $, ),  }

Follow(Y) = { +, $, ),  }

Follow(F) = { *, +, $, ),  }











11  Construct a Recursive Parser 

recursive.c

#include<stdio.h>
#include<string.h>
#include<ctype.h>
 
char input[10];
int i,error;
void E();
void T();
void Eprime();
void Tprime();
void F(); 
          main()
          {
i=0;
error=0;
                printf("Enter an arithmetic expression   :  "); // Eg: a+a*a
                gets(input);
                E();
                if(strlen(input)==i&&error==0)
                        printf("\nAccepted..!!!\n");
                else printf("\nRejected..!!!\n");
                          }
        
          
void E()
{
     T();
     Eprime();
}
void Eprime()
{
     if(input[i]=='+')
     {
     i++;
     T();
     Eprime();
     }
     }
void T()
{
     F();
     Tprime();
}
void Tprime()
{
     if(input[i]=='*')
     {
                      i++;
                      F();
                      Tprime();
                      }
                      }
     void F()
     {
          if(isalnum(input[i]))i++;
          else if(input[i]=='(')
          {
          i++;
          E();
          if(input[i]==')')
          i++;

          else error=1;
            }
        
          else error=1;
          }



Output
[cs15071@LabServer ~]$ cc ff.c
[cs15071@LabServer ~]$ ./a.out

a+(a*a)  a+a*a     Accepted
a+a+a*a+a            Accepted
a***a                   Rejected



